PRACTICAL NO. 01 
AIM: Generate the state-space possibilities. 
Q.1) Water Jug Problem 
CODE: 
def water_jug_manual_path(): 
    #Each step in the format (Jug1, Jug2) 
    steps = [] 
    #Step 1: (0,0) -> Initial state 
    a, b = 0, 0 
    steps.append((a, b)) 
    #step 2: Fill Jug1 -> (5, 4) 
    a = 5 
    steps.append((a, b)) 
    #step 3: Pour Jug1 -> Jug2 -> (1, 4) 
    transfer = min(a, 4 - b) #5 can give 4 
    a -= transfer 
    b += transfer 
    steps.append((a, b)) 
    #step 4: Empty Jug2 -> (1, 0) 
    b = 0 
    steps.append((a, b)) 
    #step 5: Pour Jug1 -> Jug2 _> (0, 1) 
    transfer = min(a, 4 - b) #1 can go into empty 4L jug 
    a -= transfer 
    b += transfer 
    steps.append((a, b)) 
    #step 6: Fill Jug1 -> (5, 1) 
    a = 5 
    steps.append((a, b)) 
    #step 7: Pour Jug1 -> Jug2 -> (2, 4) 
    transfer = min(a, 4 - b) #only 3 can go into 3 remaining in 
    a -= transfer 
    b += transfer 
    steps.append((a, b)) 
    #step 8: Pour Jug2 -> (2, 0) Goal reached 
    b = 0 
    steps.append((a, b)) 
    #Print the path 
    print("steps to reach (2, 0): ") 
    for idx, state in enumerate(steps): 
        print(f"Steps {idx}: Jug1 = {state[0]}L, Jug2 = {state[1]}L ") 
#Run the function 
water_jug_manual_path() 
 
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
 
Q.2)  8-Puzzle Problem 
CODE: 
from collections import deque 
goal = '123456780' 
moves = { 
    0: [1, 3], 
    1: [0, 2, 4], 
    2: [1, 5], 
    3: [0, 4, 6], 
    4: [1, 3, 5, 7], 
    5: [2, 4, 8], 
    6: [3, 7], 
    7: [4, 6, 8], 
    8: [5, 7]    
} 
def bfs(start): 
    visited = set() 
    queue = deque([(start, [])]) 
    while queue: 
        state, path = queue.popleft() 
        if state == goal: 
            return path + [state] 
        if state in visited: 
            continue 
        visited.add(state) 
        zero = state.index('0') 
        for move in moves[zero]: 
            new_state = list(state) 
            new_state[zero], new_state[move] = new_state[move], new_state[zero] 
            queue.append(("".join(new_state), path + [state])) 
    return None 
start = '123456708'  # valid start state 
solution = bfs(start) 
if solution: 
    print("Steps to solve:") 

    for s in solution: 
        print(s[0:3]) 
        print(s[3:6]) 
        print(s[6:9]) 
        print("---") 
else: 
    print("No solution found")



xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx