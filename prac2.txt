PRACTICAL 2 : 
--------------------------------------------------------

PRACTICAL NO. 02-RETRIVAL MODELS
AIM: Implement the vector space model with TFIDF weighting and cosine similarity
Code: 
import re
import math
from collections import Counter

def tokenize(text):
    """Convert text to lowercase and extract alphanumeric tokens."""
    return re.findall(r'\w+', text.lower())

def build_vector(tokens, vocab):
    """Create a term-frequency vector based on a vocabulary."""
    freq = Counter(tokens)
    return [freq.get(term, 0) for term in vocab]

def cosine_similarity(vec1, vec2):
    """Calculate cosine similarity between two vectors."""
    dot_product = sum(a * b for a, b in zip(vec1, vec2))
    norm1 = math.sqrt(sum(a * a for a in vec1))
    norm2 = math.sqrt(sum(b * b for b in vec2))
    if norm1 == 0 or norm2 == 0:
        return 0.0
    return dot_product / (norm1 * norm2)

def main():
    # Step 0: Input documents and query
    n = int(input("Enter number of documents: "))
    documents = []
    for i in range(n):
        documents.append(input(f"Enter document {i+1}: "))
    query = input("Enter your query: ")

    # Tokenize documents and query
    doc_tokens = [tokenize(doc) for doc in documents]
    query_tokens = tokenize(query)

    # Step 1: Display documents
    print("\nStep 1: Documents")
    for i, doc in enumerate(documents, 1):
        print(f"Document {i}: {doc}")

    # Step 2: Build vocabulary
    vocab_set = set()
    for tokens in doc_tokens:
        vocab_set.update(tokens)
    print("\nStep 2: Vocabulary")
    print(vocab_set)

    # Step 3: Sort vocabulary
    sorted_vocab = sorted(vocab_set)
    print("\nStep 3: Sorted Vocabulary")
    print(sorted_vocab)

    # Step 4: Create vectors
    doc_vectors = [build_vector(tokens, sorted_vocab) for tokens in doc_tokens]
    query_vector = build_vector(query_tokens, sorted_vocab)

    print("\nStep 4: Vector Space Representation")
    print(f"Sorted Vocabulary: {sorted_vocab}")
    print(f"Query Vector: {query_vector}")
    for i, vec in enumerate(doc_vectors, 1):
        print(f"Document {i} Vector: {vec}")

    # Step 5: Calculate cosine similarities
    similarities = []
    print("\nStep 5: Cosine Similarities")
    for i, doc_vec in enumerate(doc_vectors, 1):
        similarity = cosine_similarity(query_vector, doc_vec)
        similarities.append(similarity)
        print(f"Query vs Document {i}: {similarity:.4f}")

    # Step 6: Display final similarities
    print("\nStep 6: Ranking")
    for i, sim in enumerate(similarities, 1):
        print(f"Document {i}: {sim:.4f}")

if __name__ == "__main__":
    main()

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
Boolean Retrival

def get_input():
    num_documents = int(input("Enter number of documents: "))
    
    documents = []
    for i in range(num_documents):
        print(f"Enter terms for document {i + 1} (space separated): ")
        doc = input().split()
        documents.append(doc)
    
    query = input("Enter the query (use AND, OR, NOT operators if needed): ").split()

    return documents, query, num_documents

def get_vocab(documents):
    vocab = []
    seen = set()
    for doc in documents:
        for term in doc:
            if term not in seen:
                seen.add(term)
                vocab.append(term)
    return vocab

def create_term_document_matrix(documents, vocab):
    term_doc_matrix = []
    for doc in documents:
        doc_vector = []
        for term in vocab:
            doc_vector.append(1 if term in doc else 0)
        term_doc_matrix.append(doc_vector)
    return term_doc_matrix

def term_vector(term, vocab, term_doc_matrix):
    """Return a vector for a single term for all documents"""
    if term not in vocab:
        # If term not in vocab, vector is all zeros (term absent in all docs)
        return [0] * len(term_doc_matrix)
    index = vocab.index(term)
    return [doc_vector[index] for doc_vector in term_doc_matrix]

def boolean_and(vec1, vec2):
    return [v1 & v2 for v1, v2 in zip(vec1, vec2)]

def boolean_or(vec1, vec2):
    return [v1 | v2 for v1, v2 in zip(vec1, vec2)]

def boolean_not(vec):
    return [1 - v for v in vec]

def evaluate_query(query_tokens, vocab, term_doc_matrix):
    """
    Evaluate a boolean query supporting AND, OR, NOT.
    Query tokens must be space-separated terms/operators.
    Operators supported: AND, OR, NOT
    If no operator between terms, AND is assumed.
    """

    def get_next_operand(index):
        # parse next operand (term or NOT term)
        if index < len(query_tokens) and query_tokens[index].upper() == "NOT":
            # next token is a NOT operator
            index += 1
            if index >= len(query_tokens):
                raise ValueError("NOT operator at end of query with no term")
            term = query_tokens[index]
            vec = boolean_not(term_vector(term, vocab, term_doc_matrix))
            return vec, index + 1
        else:
            # regular term
            term = query_tokens[index]
            vec = term_vector(term, vocab, term_doc_matrix)
            return vec, index + 1

    # parse first operand
    idx = 0
    current_vec, idx = get_next_operand(idx)

    while idx < len(query_tokens):
        op = query_tokens[idx].upper()
        if op == "AND":
            idx += 1
            right_vec, idx = get_next_operand(idx)
            current_vec = boolean_and(current_vec, right_vec)
        elif op == "OR":
            idx += 1
            right_vec, idx = get_next_operand(idx)
            current_vec = boolean_or(current_vec, right_vec)
        else:
            # If no operator, default to AND
            right_vec, idx = get_next_operand(idx)
            current_vec = boolean_and(current_vec, right_vec)

    return current_vec

def print_results(vocab, term_doc_matrix, query_vector):
    print("\nVocabulary (in order of appearance):", vocab)

    print("\nTerm-Document Incidence Matrix:")
    for i, row in enumerate(term_doc_matrix):
        print(f"Document {i + 1}: {row}")
    
    print("\nQuery Result Vector:", query_vector)

    print("\nBoolean Retrieval Results (True means relevant):")
    for i, val in enumerate(query_vector):
        print(f"Document {i + 1}: {'Relevant' if val == 1 else 'Not Relevant'}")

def main():
    documents, query, num_documents = get_input()
    vocab = get_vocab(documents)
    term_doc_matrix = create_term_document_matrix(documents, vocab)
    query_vector = evaluate_query(query, vocab, term_doc_matrix)
    print_results(vocab, term_doc_matrix, query_vector)

if __name__ == "__main__":
    main()

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX




