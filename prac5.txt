PRACTICAL 5 : 
--------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt
from sklearn.svm import SVC
from sklearn.metrics import ndcg_score

# ---- Step 1: Take user input ----
num_queries = int(input("Enter number of queries: "))
X = []
y = []
query_ids = []

for q in range(1, num_queries + 1):
    num_docs = int(input(f"\nEnter number of documents for Query {q}: "))
    for d in range(1, num_docs + 1):
        features = list(map(float, input(f"Enter 2D features (x1 x2) for Query {q}, Doc {d}: ").split()))
        relevance = int(input(f"Enter relevance score for Query {q}, Doc {d}: "))
        X.append(features)
        y.append(relevance)
        query_ids.append(q)

X = np.array(X)
y = np.array(y)
query_ids = np.array(query_ids)

# ---- Step 2: Convert to pairwise data for RankSVM ----
def make_pairs(X, y, qids):
    X_pairs = []
    y_pairs = []
    for q in np.unique(qids):
        q_mask = qids == q
        X_q, y_q = X[q_mask], y[q_mask]
        for i in range(len(y_q)):
            for j in range(len(y_q)):
                if y_q[i] > y_q[j]:
                    X_pairs.append(X_q[i] - X_q[j])
                    y_pairs.append(1)
                elif y_q[i] < y_q[j]:
                    X_pairs.append(X_q[i] - X_q[j])
                    y_pairs.append(-1)
    return np.array(X_pairs), np.array(y_pairs)

X_pairs, y_pairs = make_pairs(X, y, query_ids)

# ---- Step 3: Train RankSVM ----
clf = SVC(kernel="linear")
clf.fit(X_pairs, y_pairs)

# ---- Step 4: Predict ranking scores ----
scores = clf.decision_function(X)

# ---- Step 5: Evaluate using NDCG ----
true_relevance = [y[query_ids == q] for q in np.unique(query_ids)]
pred_scores = [scores[query_ids == q] for q in np.unique(query_ids)]
ndcgs = [ndcg_score([t], [p]) for t, p in zip(true_relevance, pred_scores)]

print("\n---- Ranking Results ----")
for q in np.unique(query_ids):
    docs = np.where(query_ids == q)[0]
    q_scores = scores[docs]
    q_labels = y[docs]
    ranked_docs = sorted(zip(docs, q_scores, q_labels), key=lambda x: -x[1])
    print(f"\nQuery {q} ranking:")
    for doc_id, sc, rel in ranked_docs:
        print(f"  Doc {doc_id + 1}: Score={sc:.3f}, Relevance={rel}")

print("\nNDCG per query:", ndcgs)
print("Mean NDCG:", np.mean(ndcgs))

# ---- Step 6: Plot Data Points + Hyperplane ----
if X.shape[1] == 2:  # only works for 2D features
    w = clf.coef_[0]
    b = clf.intercept_[0]
    x_min, x_max = X[:, 0].min() - 1, X[:, 0].max() + 1
    xx = np.linspace(x_min, x_max, 100)
    yy = -(w[0] * xx + b) / w[1]

    plt.figure(figsize=(7, 6))
    scatter = plt.scatter(X[:, 0], X[:, 1], c=y, s=80, cmap="viridis", edgecolors='k')
    plt.plot(xx, yy, 'r-', label="Hyperplane")
    plt.xlabel("Feature 1 (x1)")
    plt.ylabel("Feature 2 (x2)")
    plt.title("RankSVM Hyperplane and Data Points")
    plt.legend()
    plt.colorbar(scatter, label="Relevance")
    plt.show()

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

import pandas as pd

# Step 1: Load Excel file
df = pd.read_excel("Naive_Bayes.xlsx")  # Replace with your Excel file name

print("Original Data:")
print(df)
print("\nTotal Records:", len(df))

# Step 2: Prior Probabilities
total = len(df)
fever_yes = len(df[df["Fever"] == "Yes"])
fever_no = total - fever_yes

p_fever_yes = fever_yes / total
p_fever_no = fever_no / total

print("\nStep 1: Prior Probabilities")
print(f"P(Fever=Yes) = {fever_yes}/{total} = {p_fever_yes:.4f}")
print(f"P(Fever=No)  = {fever_no}/{total} = {p_fever_no:.4f}")

# Step 3: Conditional Probabilities
covid_yes_given_fever_yes = len(df[(df["Covid"] == "Yes") & (df["Fever"] == "Yes")]) / fever_yes
flu_yes_given_fever_yes = len(df[(df["Flu"] == "Yes") & (df["Fever"] == "Yes")]) / fever_yes

covid_yes_given_fever_no = len(df[(df["Covid"] == "Yes") & (df["Fever"] == "No")]) / fever_no
flu_yes_given_fever_no = len(df[(df["Flu"] == "Yes") & (df["Fever"] == "No")]) / fever_no

print("\nStep 2: Conditional Probabilities")
print(f"P(Covid=Yes | Fever=Yes) = {covid_yes_given_fever_yes:.4f}")
print(f"P(Flu=Yes   | Fever=Yes) = {flu_yes_given_fever_yes:.4f}")
print(f"P(Covid=Yes | Fever=No)  = {covid_yes_given_fever_no:.4f}")
print(f"P(Flu=Yes   | Fever=No)  = {flu_yes_given_fever_no:.4f}")

# Step 4: Apply Naive Bayes formula

# For Fever = Yes
p_yes = covid_yes_given_fever_yes * flu_yes_given_fever_yes * p_fever_yes

# For Fever = No
p_no = covid_yes_given_fever_no * flu_yes_given_fever_no * p_fever_no

print("\nStep 3: Naive Bayes Probability Calculation")
print(f"P(Fever=Yes | Flu=Yes, Covid=Yes) = "
      f"{covid_yes_given_fever_yes:.4f} * {flu_yes_given_fever_yes:.4f} * {p_fever_yes:.4f} = {p_yes:.4f}")
print(f"P(Fever=No  | Flu=Yes, Covid=Yes) = "
      f"{covid_yes_given_fever_no:.4f} * {flu_yes_given_fever_no:.4f} * {p_fever_no:.4f} = {p_no:.4f}")

# Step 5: Normalize the result
total_prob = p_yes + p_no
norm_yes = p_yes / total_prob
norm_no = p_no / total_prob

print("\nStep 4: Normalize Probabilities")
print(f"Normalized P(Fever=Yes | Flu=Yes, Covid=Yes) = {norm_yes:.4f}")
print(f"Normalized P(Fever=No  | Flu=Yes, Covid=Yes) = {norm_no:.4f}")

# Final Prediction
print("\nFinal Prediction:")
if norm_yes > norm_no:
    print("Prediction: Fever = YES")
else:
    print("Prediction: Fever = NO")

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX