Practical No.5
AIM : Simulation of tic-tac-toe game using Min-Max Search & Alpha Beta Pruning
A] Tic-Tac-Toe
CODE :
board = [' ' for _ in range(9)]
player = 'X'
def show_board():
    print(f'|{board[0]}|{board[1]}|{board[2]}|')
    print('----------------')
    print(f'|{board[3]}|{board[4]}|{board[5]}|')
    print('----------------')
    print(f'|{board[6]}|{board[7]}|{board[8]}|')
def is_winner(p):
    return(
        (board[0] == p  and board[1] == p and board[2] == p)or
        (board[3] == p  and board[4] == p and board[5] == p)or
        (board[6] == p  and board[7] == p and board[8] == p)or
        (board[0] == p  and board[3] == p and board[6] == p)or
        (board[1] == p  and board[4] == p and board[7] == p)or
        (board[2] == p  and board[5] == p and board[8] == p)or
        (board[0] == p  and board[4] == p and board[8] == p)or
        (board[2] == p  and board[4] == p and board[6] == p)
    )
def is_tie():
    #checks if the board is full
    return ' ' not in board
def game():
    global player
    while True:
        show_board()
        try:
            move = int(input(f"Player {player} enter 0-8: "))
            if 0 <= move <= 8 and board[move] == ' ':
                board[move] = player
                if is_winner(player):
                    show_board()
                    print(f"Player {player} wins!")
                    break
                elif is_tie():
                    show_board()
                    print("It's a tie!")
                    break
                #switch player
                if player == 'X':
                    player = 'O'
                else:
                    player = 'X'
            else:
                print("Invalid move")
        except(ValueError, IndexError):
            print("Invalid input. Enter a number 0-8")
game()


xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

2] Alpha Beta Pruning
CODE :
tree={
    'A':['B', 'C'],
    'B':['D','E'],
    'C':['F','G'],
    'D':[2, 3],
    'E':[5, 9],
    'F':[0, 1],
    'G':[7, 5]
}
def minimax_alpha_beta(node, depth, alpha, beta, max_player):
    if depth == 0:
        if node in tree:
            return tree[node][0] if max_player else tree[node][0]
        else:
            return node

    if max_player:
        value = float('-inf')
        for child in tree[node]:
            value = max(value, minimax_alpha_beta(child, depth -1 , alpha, beta, False))
            alpha = max(alpha, value)
            if alpha >= beta:
                print(f"Pruning branch at node {node}")
                break
        return value
    else:
        value = float('inf')
        for child in tree[node]:
            value = min(value, minimax_alpha_beta(child, depth - 1, alpha, beta, True))
            beta = min(beta, value)
            if beta <= alpha:
                print(f"Pruning branch at node {node}")
                break
        return value
best_score = minimax_alpha_beta('A', 3, float('-inf'), float('inf'),True)
print(f"The best score is: {best_score}")

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx