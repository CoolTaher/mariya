PRACTICAL 8 : 
--------------------------------------------------------

import numpy as np  # Move the import outside of the function

def hits_algorithm(adj_matrix, iterations):
    n = len(adj_matrix)
    hub_scores = np.ones(n)
    auth_scores = np.ones(n)

    for it in range(iterations):
        # Step 1: Update Authority Scores (incoming links)
        new_auth = np.dot(adj_matrix.T, hub_scores)
        # Normalize
        auth_norm = np.sum(new_auth)
        if auth_norm != 0:
            new_auth = new_auth / auth_norm

        # Step 2: Update Hub Scores (outgoing links)
        new_hub = np.dot(adj_matrix, new_auth)
        # Normalize
        hub_norm = np.sum(new_hub)
        if hub_norm != 0:
            new_hub = new_hub / hub_norm

        # Update for next iteration
        auth_scores = new_auth
        hub_scores = new_hub

        # Optional: Display iteration results
        print(f"\nIteration {it+1}:")
        print("Authority Scores:", np.round(auth_scores, 4))
        print("Hub Scores      :", np.round(hub_scores, 4))

    return auth_scores, hub_scores


# ---------------- Main Program ----------------
# Input adjacency matrix from user
n = int(input("Enter number of nodes: "))
print("Enter adjacency matrix row by row (space separated):")

adj_matrix = []
for i in range(n):
    row = list(map(int, input(f"Row {i+1}: ").split()))
    adj_matrix.append(row)

iterations = int(input("Enter number of iterations (k): "))

# Run HITS Algorithm
authority_scores, hub_scores = hits_algorithm(np.array(adj_matrix), iterations)

# Final result
print("\nFinal Authority Scores:")
for idx, score in enumerate(authority_scores):
    print(f"Node {chr(65+idx)}: {score:.4f}")

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

from fractions import Fraction

def get_transition_matrix(n):
    print("Enter the Transition Matrix (as fractions like 1/2, 1/3 or 0):")
    matrix = []
    for i in range(n):
        row = input(f"Row {i+1} (space-separated): ").split()
        row_fractions = [Fraction(frac) for frac in row]
        matrix.append(row_fractions)
    return matrix

def pagerank(T, iterations):
    n = len(T)
    r = [Fraction(1, n)] * n  # Initial rank vector r0
    print("\nInitial Rank Vector r0:")
    for i in range(n):
        print(f"r0[{i}] = {r[i]}")

    for it in range(1, iterations + 1):
        new_r = []
        print(f"\n--- Iteration {it} ---")
        for i in range(n):
            terms = [f"{T[i][j]}*{r[j]}" for j in range(n)]
            values = [T[i][j] * r[j] for j in range(n)]
            sum_val = sum(values)
            expression = " + ".join(terms)
            print(f"r{it}[{i}] = {expression} = {sum_val} ({float(sum_val):.4f})")
            new_r.append(sum_val)
        r = new_r
    return r

# ---------- MAIN ----------
n = int(input("Enter number of pages (nodes): "))
T = get_transition_matrix(n)
iterations = int(input("Enter number of iterations to perform: "))

print("\nTransition Matrix (as Fractions):")
for row in T:
    print(row)

final_ranks = pagerank(T, iterations)

print("\nFinal PageRank Vector:")
for i, val in enumerate(final_ranks):
    print(f"Page {i}: {val} ({float(val):.4f})")

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX